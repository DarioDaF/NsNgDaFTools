"use strict";

/************************************/
/* DaF Local Components and Modules */
/* for Angular - 2018 Dario Fagotto */
/************************************/

const VERSION = "1.3"

const HEADER = `// DO NOT EDIT THIS FILE
// This code is automatically generated by DaF Local Components and Modules V. ${VERSION}
`;

const fs = require("fs");
const path = require("path");
const glob = require("glob"); // Install as DEV package!

function titleCase(s) {
  return s.slice(0, 1).toUpperCase() + s.slice(1);
}

function convName(s) {
  return s.split("-").map(titleCase).join("");
}

function convNameRepl(s, remEl, addEl) {
  return convName(path.basename(s, remEl)) + addEl;
}

function removeEnd(s, end) {
  return s.endsWith(end) ? s.slice(0, -end.length) : s;
}

function removeExt(s) {
  let lDot = s.lastIndexOf(".");
  let lSlash = s.lastIndexOf("/");
  return lDot > lSlash ? s.substr(0, lDot) : s;
}

function fileListToRefs(fList, remEl, addEl) {
  return fList.map((el) => {
    let elNorm = removeExt(el);
    return {
      rel: elNorm,
      name: convNameRepl(elNorm, remEl, addEl)
    };
  });
}

function genTsWrapper(objRefs, allObjName) {
  let impStatement = objRefs.reduce((acc, curr) => {
    return acc + `import { ${curr.name} } from "${curr.rel}";\n`;
  }, "");

  let objList = objRefs.reduce((acc, curr) => {
    return acc + `${curr.name}, `;
  }, "");

  let expStatement = `export { ${objList}};\n`;

  let allStatement = `export const ${allObjName} = [ ${objList}];\n`;

  return `${HEADER}\n${impStatement}\n${expStatement}\n${allStatement}\n`;
}

// Main

module.exports = {
    updateDaFTsLocals: function(appPath) {
    // Create module import
    glob("./*/*.module.ts", { cwd: appPath }, (e, mods) => {
      if(e != null) {
        throw e;
      }
      // Add them to the main importer
      let modRefs = fileListToRefs(mods, ".module", "Module");
      fs.writeFile(path.join(appPath, "_daf_mods.ts"), genTsWrapper(modRefs, "LOCAL_MODS"), (e) => {
        if(e != null) {
          throw e;
        }
      });
    });

    // Create component imports
    glob("./*/", { cwd: appPath }, (e, compdirs) => {
      if(e != null) {
        throw e;
      }
      // Match all dirs
      for(let compdir of compdirs) {
        ((compdir) => {
          glob("./*.component.ts", { cwd: path.join(appPath, compdir) }, function(e, comps) {
            if(e != null) {
              throw e;
            }
            // And search for components
            if(comps.length > 0) {
              // Don't create info in non component dirs!
              console.log(`${compdir} <- ${comps.join(", ")}`);

              let compRefs = fileListToRefs(comps, ".component", "Component");
              fs.writeFile(path.join(appPath, compdir, "_daf_comps.ts"), genTsWrapper(compRefs, "LOCAL_COMPS"), (e) => {
                if(e != null) {
                  throw e;
                }
              });
            } else {
              console.log(`${compdir} is not a component directory`);
            }
          });
        })(compdir);
      }
    });
  }
};

if(require.main === module) {
  // process.argv = ["node", "<filename>.js", ...];

  function helpCLI() {
    console.error("Invalid arguments: expected [<app-directory>]\n");
  }

  if((process.argv.length < 2) || (process.argv.length > 3)) {
    helpCLI();
    process.exit(1);
  }

  const appPath =
    process.argv.length >= 3 ?
    process.argv[2] :
    path.join(__dirname, "app");

  module.exports.updateDaFTsLocals(appPath);
}
